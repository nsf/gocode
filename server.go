package main

import (
	"fmt"
	"net"
	"net/rpc"
	"os"
	"runtime"
)

func doServer() int {
	gConfig.read()

	addr := *gAddr
	if *gSock == "unix" {
		addr = getSocketFilename()
		if fileExists(addr) {
			fmt.Printf("unix socket: '%s' already exists\n", addr)
			return 1
		}
	}
	gDaemon = newDaemon(*gSock, addr)
	if *gSock == "unix" {
		// cleanup unix socket file
		defer os.Remove(addr)
	}

	rpc.Register(new(RPC))

	gDaemon.loop()
	return 0
}

//-------------------------------------------------------------------------
// daemon
//-------------------------------------------------------------------------

type daemon struct {
	listener     net.Listener
	cmdIn       chan int
	autocomplete *autoCompleteContext
	pkgcache     packageCache
	declcache    *declCache
	env          gocodeEnv
}

func newDaemon(network, address string) *daemon {
	var err error

	d := new(daemon)
	d.listener, err = net.Listen(network, address)
	if err != nil {
		panic(err)
	}

	d.cmdIn = make(chan int, 1)
	d.pkgcache = newPackageCache()
	d.declcache = newDeclCache(&d.env)
	d.autocomplete = newAutoCompleteContext(d.pkgcache, d.declcache)
	d.env.get()
	return d
}

func (this *daemon) dropCache() {
	this.pkgcache = newPackageCache()
	this.declcache = newDeclCache(&this.env)
	this.autocomplete = newAutoCompleteContext(this.pkgcache, this.declcache)
}

const (
	daemonClose = iota
)

func (this *daemon) loop() {
	connIn := make(chan net.Conn)
	go func() {
		for {
			c, err := this.listener.Accept()
			if err != nil {
				panic(err)
			}
			connIn <- c
		}
	}()
	for {
		// handle connections or server CMDs (currently one CMD)
		select {
		case c := <-connIn:
			rpc.ServeConn(c)
			runtime.GC()
		case cmd := <-this.cmdIn:
			switch cmd {
			case daemonClose:
				return
			}
		}
	}
}

func (this *daemon) close() {
	this.cmdIn <- daemonClose
}

var gDaemon *daemon

//-------------------------------------------------------------------------
// server_* functions
//
// Corresponding client_* functions are autogenerated by goremote.
//-------------------------------------------------------------------------

func serverAutoComplete(file []byte, filename string, cursor int, env gocodeEnv) (c []candidate, d int) {
	defer func() {
		if err := recover(); err != nil {
			printBacktrace(err)
			c = []candidate{
				{"PANIC", "PANIC", declInvalid},
			}

			// drop cache
			gDaemon.dropCache()
		}
	}()
	if gDaemon.env != env {
		gDaemon.env = env
		gDaemon.dropCache()
	}
	if *gDebug {
		fmt.Printf("Got autocompletion request for '%s'\n", filename)
		fmt.Printf("Cursor at: %d\n", cursor)
		fmt.Println("-------------------------------------------------------")
		fmt.Print(string(file[:cursor]))
		fmt.Print("#")
		fmt.Print(string(file[cursor:]))
		fmt.Println("-------------------------------------------------------")
	}
	candidates, d := gDaemon.autocomplete.apropos(file, filename, cursor)
	if *gDebug {
		fmt.Printf("Offset: %d\n", d)
		fmt.Printf("Number of candidates found: %d\n", len(candidates))
		fmt.Printf("Candidates are:\n")
		for _, c := range candidates {
			abbr := fmt.Sprintf("%s %s %s", c.Class, c.Name, c.Type)
			if c.Class == declFunc {
				abbr = fmt.Sprintf("%s %s%s", c.Class, c.Name, c.Type[len("func"):])
			}
			fmt.Printf("  %s\n", abbr)
		}
		fmt.Println("=======================================================")
	}
	return candidates, d
}

func serverCursorTypePkg(file []byte, filename string, cursor int) (typ, pkg string) {
	defer func() {
		if err := recover(); err != nil {
			printBacktrace(err)

			// drop cache
			gDaemon.dropCache()
		}
	}()
	return gDaemon.autocomplete.cursorTypePkg(file, filename, cursor)
}

func serverClose(notused int) int {
	gDaemon.close()
	return 0
}

func serverStatus(notused int) string {
	return gDaemon.autocomplete.status()
}

func serverDropCache(notused int) int {
	// drop cache
	gDaemon.dropCache()
	return 0
}

func serverSet(key, value string) string {
	if key == "\x00" {
		return gConfig.list()
	} else if value == "\x00" {
		return gConfig.listOption(key)
	}
	return gConfig.setOption(key, value)
}
